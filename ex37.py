# Symbols
# no code

# and - logical and
# del - delete (free memory used by) object/variable/etc
# from - when importing particular modules, 'from' a library, import a particular module
# not - logical not
# while - used to loop, while condition is true
# as - set an alias for an imported module
# elif - else if
# global - When wanting to change scope of local variable to global variable.
# or - logical or
# with - alternative to try/finally block. Great for use with opening files. With ensure file closes despite exception
# assert - Used for ensuring variables evaluate to expected values. If not, error is output. Great for debugging.
# else - else
# if - if
# pass - used for empty code blocks to literally pass that block, such as in an if statement. (if i % 2 == 0: pass)
# yield - it's complicated :^) https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do
# break - break out of loop
# except - part of try/except pair. Try code block, if exception caught, do instructions in `except:` block
# import - used for importing packages/libraries/modules
# print - print strings, variable values, etc.
# class - used as an object blueprint. collection of variables and functions/methods to be instantiated later.
# exec - execute python code dynamically. I imagine only in IDLE.
# in - used to refer to lists/arrays, maybe more stuff too. "for x in range(0,5)'
# raise - create user defined exception
# continue - interrupt loop and continue to next cycle. Sort of like using `pass`
# finally - try/finally pair, always runs code despite any exception being caught
# is - testing object identity, not equality to other objects
# return - returns value from function
# def - used to define function
# for - for loop.
# lambda - essentially equations, nicer syntax. y = x * x but it's `y = lambda x: x*x`
# try - try/exception/finally. Used to try code, and do something else in case an exception is thrown. Finally block
# will run in both cases, regardless of exception thrown.
